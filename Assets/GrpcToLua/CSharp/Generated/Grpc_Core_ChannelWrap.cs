//this source code was auto-generated by tolua#, do not modify it
using System;
using LuaInterface;

public class Grpc_Core_ChannelWrap
{
	public static void Register(LuaState L)
	{
		L.BeginClass(typeof(Grpc.Core.Channel), typeof(Grpc.Core.ChannelBase));
		L.RegFunction("WaitForStateChangedAsync", WaitForStateChangedAsync);
		L.RegFunction("TryWaitForStateChangedAsync", TryWaitForStateChangedAsync);
		L.RegFunction("ConnectAsync", ConnectAsync);
		L.RegFunction("CreateCallInvoker", CreateCallInvoker);
		L.RegFunction("New", _CreateGrpc_Core_Channel);
		L.RegFunction("__tostring", ToLua.op_ToString);
		L.RegVar("State", get_State, null);
		L.RegVar("ResolvedTarget", get_ResolvedTarget, null);
		L.RegVar("ShutdownToken", get_ShutdownToken, null);
		L.EndClass();
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int _CreateGrpc_Core_Channel(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 2)
			{
				string arg0 = ToLua.CheckString(L, 1);
				Grpc.Core.ChannelCredentials arg1 = (Grpc.Core.ChannelCredentials)ToLua.CheckObject<Grpc.Core.ChannelCredentials>(L, 2);
				Grpc.Core.Channel obj = new Grpc.Core.Channel(arg0, arg1);
				ToLua.PushObject(L, obj);
				return 1;
			}
			else if (count == 3 && TypeChecker.CheckTypes<int, Grpc.Core.ChannelCredentials>(L, 2))
			{
				string arg0 = ToLua.CheckString(L, 1);
				int arg1 = (int)LuaDLL.lua_tonumber(L, 2);
				Grpc.Core.ChannelCredentials arg2 = (Grpc.Core.ChannelCredentials)ToLua.ToObject(L, 3);
				Grpc.Core.Channel obj = new Grpc.Core.Channel(arg0, arg1, arg2);
				ToLua.PushObject(L, obj);
				return 1;
			}
			else if (count == 3 && TypeChecker.CheckTypes<Grpc.Core.ChannelCredentials, System.Collections.Generic.IEnumerable<Grpc.Core.ChannelOption>>(L, 2))
			{
				string arg0 = ToLua.CheckString(L, 1);
				Grpc.Core.ChannelCredentials arg1 = (Grpc.Core.ChannelCredentials)ToLua.ToObject(L, 2);
				System.Collections.Generic.IEnumerable<Grpc.Core.ChannelOption> arg2 = (System.Collections.Generic.IEnumerable<Grpc.Core.ChannelOption>)ToLua.ToObject(L, 3);
				Grpc.Core.Channel obj = new Grpc.Core.Channel(arg0, arg1, arg2);
				ToLua.PushObject(L, obj);
				return 1;
			}
			else if (count == 4)
			{
				string arg0 = ToLua.CheckString(L, 1);
				int arg1 = (int)LuaDLL.luaL_checknumber(L, 2);
				Grpc.Core.ChannelCredentials arg2 = (Grpc.Core.ChannelCredentials)ToLua.CheckObject<Grpc.Core.ChannelCredentials>(L, 3);
				System.Collections.Generic.IEnumerable<Grpc.Core.ChannelOption> arg3 = (System.Collections.Generic.IEnumerable<Grpc.Core.ChannelOption>)ToLua.CheckObject<System.Collections.Generic.IEnumerable<Grpc.Core.ChannelOption>>(L, 4);
				Grpc.Core.Channel obj = new Grpc.Core.Channel(arg0, arg1, arg2, arg3);
				ToLua.PushObject(L, obj);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to ctor method: Grpc.Core.Channel.New");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int WaitForStateChangedAsync(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 2)
			{
				Grpc.Core.Channel obj = (Grpc.Core.Channel)ToLua.CheckObject<Grpc.Core.Channel>(L, 1);
				Grpc.Core.ChannelState arg0 = (Grpc.Core.ChannelState)ToLua.CheckObject(L, 2, typeof(Grpc.Core.ChannelState));
				System.Threading.Tasks.Task o = obj.WaitForStateChangedAsync(arg0);
				ToLua.PushObject(L, o);
				return 1;
			}
			else if (count == 3)
			{
				Grpc.Core.Channel obj = (Grpc.Core.Channel)ToLua.CheckObject<Grpc.Core.Channel>(L, 1);
				Grpc.Core.ChannelState arg0 = (Grpc.Core.ChannelState)ToLua.CheckObject(L, 2, typeof(Grpc.Core.ChannelState));
				System.Nullable<System.DateTime> arg1 = ToLua.CheckNullable<System.DateTime>(L, 3);
				System.Threading.Tasks.Task o = obj.WaitForStateChangedAsync(arg0, arg1);
				ToLua.PushObject(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: Grpc.Core.Channel.WaitForStateChangedAsync");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int TryWaitForStateChangedAsync(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 2)
			{
				Grpc.Core.Channel obj = (Grpc.Core.Channel)ToLua.CheckObject<Grpc.Core.Channel>(L, 1);
				Grpc.Core.ChannelState arg0 = (Grpc.Core.ChannelState)ToLua.CheckObject(L, 2, typeof(Grpc.Core.ChannelState));
				System.Threading.Tasks.Task<bool> o = obj.TryWaitForStateChangedAsync(arg0);
				ToLua.PushObject(L, o);
				return 1;
			}
			else if (count == 3)
			{
				Grpc.Core.Channel obj = (Grpc.Core.Channel)ToLua.CheckObject<Grpc.Core.Channel>(L, 1);
				Grpc.Core.ChannelState arg0 = (Grpc.Core.ChannelState)ToLua.CheckObject(L, 2, typeof(Grpc.Core.ChannelState));
				System.Nullable<System.DateTime> arg1 = ToLua.CheckNullable<System.DateTime>(L, 3);
				System.Threading.Tasks.Task<bool> o = obj.TryWaitForStateChangedAsync(arg0, arg1);
				ToLua.PushObject(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: Grpc.Core.Channel.TryWaitForStateChangedAsync");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int ConnectAsync(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 1)
			{
				Grpc.Core.Channel obj = (Grpc.Core.Channel)ToLua.CheckObject<Grpc.Core.Channel>(L, 1);
				System.Threading.Tasks.Task o = obj.ConnectAsync();
				ToLua.PushObject(L, o);
				return 1;
			}
			else if (count == 2)
			{
				Grpc.Core.Channel obj = (Grpc.Core.Channel)ToLua.CheckObject<Grpc.Core.Channel>(L, 1);
				System.Nullable<System.DateTime> arg0 = ToLua.CheckNullable<System.DateTime>(L, 2);
				System.Threading.Tasks.Task o = obj.ConnectAsync(arg0);
				ToLua.PushObject(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: Grpc.Core.Channel.ConnectAsync");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int CreateCallInvoker(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			Grpc.Core.Channel obj = (Grpc.Core.Channel)ToLua.CheckObject<Grpc.Core.Channel>(L, 1);
			Grpc.Core.CallInvoker o = obj.CreateCallInvoker();
			ToLua.PushObject(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_State(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			Grpc.Core.Channel obj = (Grpc.Core.Channel)o;
			Grpc.Core.ChannelState ret = obj.State;
			ToLua.Push(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index State on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_ResolvedTarget(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			Grpc.Core.Channel obj = (Grpc.Core.Channel)o;
			string ret = obj.ResolvedTarget;
			LuaDLL.lua_pushstring(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index ResolvedTarget on a nil value");
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_ShutdownToken(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			Grpc.Core.Channel obj = (Grpc.Core.Channel)o;
			System.Threading.CancellationToken ret = obj.ShutdownToken;
			ToLua.PushValue(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, "attempt to index ShutdownToken on a nil value");
		}
	}
}

